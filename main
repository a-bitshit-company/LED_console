TaskHandle_t taskHandles[10];
struct ctrlState{
  int X,Y;
  boolean A,B;
};
ctrlState *ctrl_A, *ctrl_B, *ctrl_T;

void setup() {
  //3 highest prio
  //essential tasks
  xTaskCreate(master,"master", 512, NULL, 3, NULL);
  xTaskCreate(inputTask,"inputs", 512, NULL, 3, NULL);

  
  taskHandles[0] = TaskHandle_t("timeTask");
  taskHandles[1] = TaskHandle_t("tempTask");
  taskHandles[2] = TaskHandle_t("pongTask");
  xTaskCreate(tempScreen,"tempAndHum", 512, NULL, 1, &taskHandles[1]);
  xTaskCreate(timeScreen,"time", 512, NULL, 1, &taskHandles[0]);
  xTaskCreate(pongScreen,"pong", 512, NULL, 1, &taskHandles[2]);
}


int currentTask;
enum Emode{Menu, Game, idle};
Emode mode = Menu;
void master(void* pvparameters){
  //has to make sure only one task is running at a time
  vTaskDelay(200 / portTICK_PERIOD_MS);
  if(mode = Menu){
    while(true){
      int taskArrLen = sizeof(taskHandles) / sizeof(TaskHandle_t);
      for(int i = 0; i<taskArrLen;i++){   
        //suspend all unwanted tasks
        if(eTaskGetState(taskHandles[i]) == eTaskState(eRunning)){
          if(i != currentTask){
            vTaskSuspend(taskHandles[i]);
          }
        }
        //start current Task if needed
        if(i = currentTask && eTaskGetState(taskHandles[i]) != eTaskState(eRunning)){
          vTaskResume(taskHandles[i]);
        }
      }
      if(ctrl_A->B)currentTask= ++currentTask%taskArrLen;
      vTaskDelay(10 / portTICK_PERIOD_MS);
    }
  }
}

void timeScreen(void* pvparameters){
  while(true){
    Serial.println("time");
    vTaskDelay(300 / portTICK_PERIOD_MS);
  }
}

void tempScreen(void* pvparameters){
  while(true){
    Serial.println("tempHum");
    vTaskDelay(300 / portTICK_PERIOD_MS);
  }
  
}

void pongScreen(void* pvparameters){
  while(true){
    Serial.println("pong");
    vTaskDelay(300 / portTICK_PERIOD_MS);
  }
}


//Controller A, controller B, temporÃ¤rer Speicher
void inputTask(void* pvparam) {
  Serial.begin(115200);
  Serial1.begin(115200, SERIAL_8N1, 16,17);
  Serial2.begin(115200, SERIAL_8N1, 9,10);
  
  ctrl_A=(ctrlState *)malloc(sizeof(ctrlState));
  ctrl_B=(ctrlState *)malloc(sizeof(ctrlState));
  ctrl_T=(ctrlState *)malloc(sizeof(ctrlState));

  char in[16];
  int i;
  for(;;) {
    while(Serial1.available()>0){
      in[i] = Serial1.read();
      
      if(in[i] == '\n'){
        i=0;
        parseInput(in, ctrl_T);
        
        ctrlState *tmp=ctrl_A;
        ctrl_A=ctrl_T;
        ctrl_T=tmp;

        printCtrl(ctrl_A);
      }else{
        i++;
      }
    }
    vTaskDelay(20);
    while(Serial2.available()>0){
      in[i] = Serial2.read();
      
      if(in[i] == '\n'){
        i=0;
        parseInput(in, ctrl_T);
        
        ctrlState *tmp=ctrl_B;
        ctrl_B=ctrl_T;
        ctrl_T=tmp;

        Serial.print("A: ");
        printCtrl(ctrl_A);
        Serial.print("B: ");
        printCtrl(ctrl_B);
      }else{
        i++;
      }
    }
    vTaskDelay(20);
  }
}
void parseInput(char str[], struct ctrlState *ctrl){
  ctrl->X = atoi(str);
  int i;
  for(i = 0; str[i] != ' '; i++);
  ctrl->Y = atoi(str+i);
  for(i++; str[i] != ' '; i++);
  ctrl->B = str[i+1]=='1';
  ctrl->A = str[i+3]=='1';
}

void printCtrl(struct ctrlState *ctrl){
  Serial.print(ctrl_T->X);
  Serial.print(" ");
  Serial.print(ctrl_T->Y);
  Serial.print(" ");
  Serial.print(ctrl_T->A);
  Serial.print(" ");
  Serial.println(ctrl_T->B);
  Serial.println();
}

void loop() {
}
