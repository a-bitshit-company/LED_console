//task handling
TaskHandle_t menuHandles[2];
int currentTask;

//Inputs
struct ctrlState{
  int X,Y;
  boolean A,B;
};
ctrlState *ctrl_A, *ctrl_B, *ctrl_T;

//mode enum
//enum Emode{menu, game, idle};
//Emode mode;
int mode;

void setup() {
   Serial.begin(115200);
   mode = 1; 
  //3 highest prio
  //essential tasks
  xTaskCreate(master,"master", 2048, NULL, 2, NULL);
  //xTaskCreate(inputTask,"inputs", 512, NULL, 3, NULL);
  //xTaskCreate(idleTask,"idle screen", 512, NULL, 1, NULL);

  
  menuHandles[0] = TaskHandle_t("timeTask");
  menuHandles[1] = TaskHandle_t("tempTask");
  menuHandles[2] = TaskHandle_t("pongTask");
 //xTaskCreate(tempScreen,"tempAndHum", 512, NULL, 1, &menuHandles[1]);
 //xTaskCreate(timeScreen,"time", 512, NULL, 1, &menuHandles[0]);
 //xTaskCreate(pongScreen,"pong", 512, NULL, 1, &menuHandles[2]);
}

//die Tasks werden aufgerufen, welche die klickbar sind brauchen eigenen Title screen der auf den knopfdruck reagiert
void master(void* pvparameters){
  //has to make sure only one task is running at a time
  vTaskDelay(200 / portTICK_PERIOD_MS);
  Serial.println("masterTask started");
  while(true){
    Serial.println("masterTask running");
    Serial.println(mode);
   if(mode == 1){
    while(true){
      /*int taskArrLen = sizeof(menuHandles) / sizeof(menuHandles[0]);
      for(int i = 0; i<taskArrLen;i++){   
        //suspend all unwanted tasks
        if(eTaskGetState(menuHandles[i]) == eTaskState(eRunning)){
          if(i != currentTask){
            vTaskSuspend(menuHandles[i]);
            Serial.print("task suspended: ");
            Serial.println(i);
          }
        }
        //start current Task if needed
        if(i = currentTask && eTaskGetState(menuHandles[i]) != eTaskState(eRunning)){
          vTaskResume(menuHandles[i]);
          Serial.print("task resumed: ");
          Serial.println(i);
        }
      }*/
      if(ctrl_A){
      if(ctrl_A->B){
        if(ctrl_A->A){
          mode = 2;
          break;
          Serial.println("mode changed to idle");
        }else{
          //currentTask= ++currentTask%taskArrLen;
          Serial.println("changed to Screen: ");
          Serial.println(currentTask);
        }
      }
      Serial.println("da passiert was");
      vTaskDelay(10 / portTICK_PERIOD_MS);
    }}
  }
  vTaskDelay(20 / portTICK_PERIOD_MS);
 }
}

void timeScreen(void* pvparameters){
  while(true){
    Serial.println("time");
    vTaskDelay(300 / portTICK_PERIOD_MS);
  }
}

void tempScreen(void* pvparameters){
  while(true){
    Serial.println("tempHum");
    vTaskDelay(300 / portTICK_PERIOD_MS);
  }
  
}

void pongScreen(void* pvparameters){
  while(true){
    //titlescreen am anfang(schrift was da kommt wenn ma klickt)
    //iwas von wegen button a gedrückt, dann spielstart und wenn beide Knöpfe 2sek gedrückt wieder menu mode
    Serial.println("pong");
    vTaskDelay(300 / portTICK_PERIOD_MS);
  }
}


//Controller A, controller B, temporärer Speicher
void inputTask(void* pvparam) {
  Serial1.begin(115200, SERIAL_8N1, 16,17);
  Serial2.begin(115200, SERIAL_8N1, 9,10);
  
  ctrl_A=(ctrlState *)malloc(sizeof(ctrlState));
  ctrl_B=(ctrlState *)malloc(sizeof(ctrlState));
  ctrl_T=(ctrlState *)malloc(sizeof(ctrlState));

  char in[16];
  int i;
  for(;;) {
    while(Serial1.available()>0){
      in[i] = Serial1.read();
      
      if(in[i] == '\n'){
        i=0;
        parseInput(in, ctrl_T);
        
        ctrlState *tmp=ctrl_A;
        ctrl_A=ctrl_T;
        ctrl_T=tmp;

        printCtrl(ctrl_A);
      }else{
        i++;
      }
    }
    vTaskDelay(20 / portTICK_PERIOD_MS);
    while(Serial2.available()>0){
      in[i] = Serial2.read();
      
      if(in[i] == '\n'){
        i=0;
        parseInput(in, ctrl_T);
        
        ctrlState *tmp=ctrl_B;
        ctrl_B=ctrl_T;
        ctrl_T=tmp;

        Serial.print("A: ");
        printCtrl(ctrl_A);
        Serial.print("B: ");
        printCtrl(ctrl_B);
      }else{
        i++;
      }
    }
    vTaskDelay(20 / portTICK_PERIOD_MS);
  }
}
void parseInput(char str[], struct ctrlState *ctrl){
  ctrl->X = atoi(str);
  int i;
  for(i = 0; str[i] != ' '; i++);
  ctrl->Y = atoi(str+i);
  for(i++; str[i] != ' '; i++);
  ctrl->B = str[i+1]=='1';
  ctrl->A = str[i+3]=='1';
}
void printCtrl(struct ctrlState *ctrl){
  Serial.print(ctrl_T->X);
  Serial.print(" ");
  Serial.print(ctrl_T->Y);
  Serial.print(" ");
  Serial.print(ctrl_T->A);
  Serial.print(" ");
  Serial.println(ctrl_T->B);
  Serial.println();
}


void idleTask(void* pvparam){
  //bla bla cooles muster und so
  //irgendein knopf gedrückt mode = menu;
  while(true){
    Serial.println("bla");
    vTaskDelay(20 / portTICK_PERIOD_MS);
  }
}

void loop() {
}
